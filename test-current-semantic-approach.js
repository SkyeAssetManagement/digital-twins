/**
 * Test Current Semantic Approach
 * Tests the semantic response engine with the Rip Curl "The Search" ad
 * Records responses from all 4 LOHAS personas
 */

import fs from 'fs/promises';
import path from 'path';
import { SemanticResponseEngine } from './src/digital_twins/semantic_response_engine.js';
import { createUnifiedVectorStore } from './src/vector_db/unified_vector_store.js';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load the test ad script
async function loadTestAd() {
  const adPath = path.join(__dirname, 'testMaterials', 'testAdScript.md');
  const adContent = await fs.readFile(adPath, 'utf8');
  return adContent;
}

// Test configuration
const testConfig = {
  approach: 'Current Semantic Engine (MiniLM embeddings)',
  model: 'Xenova/all-MiniLM-L6-v2',
  dimensions: 384,
  method: 'Semantic similarity with survey data',
  timestamp: new Date().toISOString()
};

// LOHAS segments to test
const segments = ['Leader', 'Leaning', 'Learner', 'Laggard'];

async function testCurrentApproach() {
  console.log('============================================');
  console.log('TESTING CURRENT SEMANTIC APPROACH');
  console.log('============================================');
  console.log(`Approach: ${testConfig.approach}`);
  console.log(`Model: ${testConfig.model}`);
  console.log(`Dimensions: ${testConfig.dimensions}`);
  console.log(`Method: ${testConfig.method}`);
  console.log(`Timestamp: ${testConfig.timestamp}`);
  console.log('============================================\n');
  
  // Load test ad
  const adContent = await loadTestAd();
  console.log('Test Ad: Rip Curl "The Search" Commercial');
  console.log('Content preview:', adContent.substring(0, 200) + '...\n');
  
  // Initialize unified vector store
  const vectorStore = await createUnifiedVectorStore('surf-clothing', {
    embeddingProvider: 'local-minilm'
  });
  
  // Store results
  const results = {
    metadata: testConfig,
    adContent: adContent,
    responses: {}
  };
  
  // Test each segment
  for (const segment of segments) {
    console.log(`\n${'='.repeat(60)}`);
    console.log(`Testing Segment: ${segment}`);
    console.log('='.repeat(60));
    
    // Create test twin
    const twin = {
      id: `test-${segment.toLowerCase()}`,
      segment: segment,
      persona: { 
        name: `${segment} Consumer`,
        description: `LOHAS ${segment} segment consumer`
      },
      valueSystem: getValueSystem(segment),
      characteristics: getCharacteristics(segment)
    };
    
    // Create semantic engine
    const engine = new SemanticResponseEngine(twin, vectorStore);
    
    try {
      // Initialize engine (loads survey data and pre-computes embeddings)
      console.log('Initializing semantic engine with survey data...');
      await engine.initialize();
      
      // Generate response
      console.log('Generating semantic response...');
      const startTime = Date.now();
      const response = await engine.generateSemanticResponse(adContent);
      const responseTime = Date.now() - startTime;
      
      // Display results
      console.log('\n--- RESPONSE ---');
      console.log(`Text: "${response.text}"`);
      console.log(`\nSentiment: ${response.sentiment}`);
      console.log(`Purchase Intent: ${response.purchaseIntent}/10`);
      console.log(`Response Time: ${responseTime}ms`);
      console.log(`Generated By: ${response.generatedBy}`);
      
      if (response.basedOnSurveyData) {
        console.log(`Based on Survey Data: YES`);
        if (response.surveyRespondents && response.surveyRespondents.length > 0) {
          console.log(`Survey Respondents Used: ${response.surveyRespondents.slice(0, 3).join(', ')}...`);
        }
      }
      
      // Display themes detected
      if (response.themes) {
        console.log('\n--- THEMES DETECTED ---');
        const sortedThemes = Object.entries(response.themes)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);
        
        sortedThemes.forEach(([theme, score]) => {
          const percentage = (score * 100).toFixed(1);
          const bar = 'â–ˆ'.repeat(Math.round(score * 20));
          console.log(`${theme.padEnd(15)} ${bar} ${percentage}%`);
        });
      }
      
      // Display value alignment
      if (response.valueAlignment) {
        console.log('\n--- VALUE ALIGNMENT ---');
        const topValues = Object.entries(response.valueAlignment)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 3);
        
        topValues.forEach(([value, score]) => {
          console.log(`${value.substring(0, 50)}... : ${(score * 100).toFixed(1)}%`);
        });
      }
      
      // Store results
      results.responses[segment] = {
        text: response.text,
        sentiment: response.sentiment,
        purchaseIntent: response.purchaseIntent,
        responseTime: responseTime,
        themes: response.themes,
        valueAlignment: response.valueAlignment,
        basedOnSurveyData: response.basedOnSurveyData,
        surveyRespondents: response.surveyRespondents,
        generatedBy: response.generatedBy,
        timestamp: response.timestamp
      };
      
    } catch (error) {
      console.error(`Error testing ${segment}:`, error.message);
      results.responses[segment] = {
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }
  
  // Save results to file
  const outputPath = path.join(__dirname, 'test-results', 'current-semantic-approach-results.json');
  await fs.mkdir(path.join(__dirname, 'test-results'), { recursive: true });
  await fs.writeFile(outputPath, JSON.stringify(results, null, 2));
  
  console.log('\n============================================');
  console.log('TEST COMPLETE');
  console.log(`Results saved to: ${outputPath}`);
  console.log('============================================\n');
  
  // Display summary
  console.log('SUMMARY OF RESPONSES:');
  console.log('='.repeat(60));
  
  for (const [segment, response] of Object.entries(results.responses)) {
    if (!response.error) {
      console.log(`\n${segment}:`);
      console.log(`  Response: "${response.text.substring(0, 100)}..."`);
      console.log(`  Sentiment: ${response.sentiment} | Intent: ${response.purchaseIntent}/10`);
    }
  }
  
  await vectorStore.close();
  
  return results;
}

function getValueSystem(segment) {
  const systems = {
    Leader: {
      sustainability: 0.95,
      priceSensitivity: 0.3,
      brandValues: 0.9,
      quality: 0.8,
      innovation: 0.7
    },
    Leaning: {
      sustainability: 0.6,
      priceSensitivity: 0.6,
      brandValues: 0.7,
      quality: 0.8,
      innovation: 0.6
    },
    Learner: {
      sustainability: 0.3,
      priceSensitivity: 0.8,
      brandValues: 0.4,
      quality: 0.6,
      innovation: 0.5
    },
    Laggard: {
      sustainability: 0.1,
      priceSensitivity: 0.95,
      brandValues: 0.2,
      quality: 0.5,
      innovation: 0.2
    }
  };
  
  return systems[segment] || {};
}

function getCharacteristics(segment) {
  const characteristics = {
    Leader: [
      'Actively seeks sustainable products',
      'Willing to pay 25%+ premium',
      'Environmental evangelist',
      'Influences others'
    ],
    Leaning: [
      'Balances values with practicality',
      'Willing to pay 10-15% premium',
      'Considers sustainability',
      'Quality focused'
    ],
    Learner: [
      'Price is primary factor',
      'Curious but skeptical',
      'Needs education',
      'Compares options'
    ],
    Laggard: [
      'Only cares about price',
      'Dismisses sustainability',
      'Skeptical of all claims',
      'Prefers discount stores'
    ]
  };
  
  return characteristics[segment] || [];
}

// Run the test
testCurrentApproach().catch(console.error);